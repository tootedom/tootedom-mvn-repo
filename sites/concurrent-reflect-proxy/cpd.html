<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia at Feb 24, 2013 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>CPD Results</title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
    <meta name="Date-Revision-yyyymmdd" content="20130224" />
    <meta http-equiv="Content-Language" content="en" />
        
        </head>
  <body class="composite">
    <div id="banner">
                    <div id="bannerLeft">
                Concurrent Reflection Proxy
                </div>
                    <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
            
        
                <div class="xleft">
        <span id="publishDate">Last Published: 2013-02-24</span>
                  &nbsp;| <span id="projectVersion">Version: 1.1</span>
                      </div>
            <div class="xright">                    <a href="${project.url}" title="Concurrent Reflection Proxy">Concurrent Reflection Proxy</a>
              
        
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
             
        
                                          <h5>Project Documentation</h5>
                  <ul>
                                                                                                                                                                                                                                                                          <li class="collapsed">
                          <a href="project-info.html" title="Project Information">Project Information</a>
                  </li>
                                                                                                                                                                                                            <li class="expanded">
                          <a href="project-reports.html" title="Project Reports">Project Reports</a>
                    <ul>
                      <li class="none">
                          <a href="pmd.html" title="PMD Report">PMD Report</a>
            </li>
                      <li class="none">
            <strong>CPD Report</strong>
          </li>
                      <li class="none">
                          <a href="checkstyle-aggregate.html" title="Checkstyle">Checkstyle</a>
            </li>
                      <li class="none">
                          <a href="checkstyle.html" title="Checkstyle">Checkstyle</a>
            </li>
                      <li class="none">
                          <a href="xref/index.html" title="Source Xref">Source Xref</a>
            </li>
                      <li class="none">
                          <a href="surefire-report.html" title="Surefire Report">Surefire Report</a>
            </li>
                      <li class="none">
                          <a href="cobertura/index.html" title="Cobertura Test Coverage">Cobertura Test Coverage</a>
            </li>
                      <li class="none">
                          <a href="apidocs/index.html" title="JavaDocs">JavaDocs</a>
            </li>
              </ul>
        </li>
          </ul>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                   
        
            </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section"><h2>CPD Results<a name="CPD_Results"></a></h2><p>The following document contains the results of PMD's  <a class="externalLink" href="http://pmd.sourceforge.net/cpd.html">CPD</a> 4.3.</p></div><div class="section"><h2>Duplications<a name="Duplications"></a></h2><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/greencheek/concurrent/ConcurrentWeakHashMap.java</td><td><a href="./xref/org/greencheek/concurrent/ConcurrentWeakHashMap.html#751">751</a></td></tr><tr class="a"><td>org/greencheek/jboss/ConcurrentReferenceHashMap.java</td><td><a href="./xref/org/greencheek/jboss/ConcurrentReferenceHashMap.html#1015">1015</a></td></tr><tr class="b"><td colspan='2'><div><pre>    public ConcurrentWeakHashMap(Map&lt;? extends K, ? extends V&gt; m) {
        this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1,
                      DEFAULT_INITIAL_CAPACITY),
             DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);
        putAll(m);
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings.
     *
     * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings
     */
    public boolean isEmpty() {
        final Segment&lt;K,V&gt;[] segments = this.segments;
        /*
         * We keep track of per-segment modCounts to avoid ABA
         * problems in which an element in one segment was added and
         * in another removed during traversal, in which case the
         * table was never actually empty at any point. Note the
         * similar use of modCounts in the size() and containsValue()
         * methods, which are the only other methods also susceptible
         * to ABA problems.
         */
        int[] mc = new int[segments.length];
        int mcsum = 0;
        for (int i = 0; i &lt; segments.length; ++i) {
            if (segments[i].count != 0)
                return false;
            else
                mcsum += mc[i] = segments[i].modCount;
        }
        // If mcsum happens to be zero, then we know we got a snapshot
        // before any modifications at all were made.  This is
        // probably common enough to bother tracking.
        if (mcsum != 0) {
            for (int i = 0; i &lt; segments.length; ++i) {
                if (segments[i].count != 0 ||
                    mc[i] != segments[i].modCount)
                    return false;
            }
        }
        return true;
    }

    /**
     * Returns the number of key-value mappings in this map.  If the
     * map contains more than &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt; elements, returns
     * &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt;.
     *
     * @return the number of key-value mappings in this map
     */
    public int size() {
        final Segment&lt;K,V&gt;[] segments = this.segments;
        long sum = 0;
        long check = 0;
        int[] mc = new int[segments.length];
        // Try a few times to get accurate count. On failure due to
        // continuous async changes in table, resort to locking.
        for (int k = 0; k &lt; RETRIES_BEFORE_LOCK; ++k) {
            check = 0;
            sum = 0;
            int mcsum = 0;
            for (int i = 0; i &lt; segments.length; ++i) {
                sum += segments[i].count;
                mcsum += mc[i] = segments[i].modCount;
            }
            if (mcsum != 0) {
                for (int i = 0; i &lt; segments.length; ++i) {
                    check += segments[i].count;
                    if (mc[i] != segments[i].modCount) {
                        check = -1; // force retry
                        break;
                    }
                }
            }
            if (check == sum)
                break;
        }
        if (check != sum) { // Resort to locking all segments
            sum = 0;
            for (int i = 0; i &lt; segments.length; ++i)
                segments[i].lock();
            for (int i = 0; i &lt; segments.length; ++i)
                sum += segments[i].count;
            for (int i = 0; i &lt; segments.length; ++i)
                segments[i].unlock();
        }
        if (sum &gt; Integer.MAX_VALUE)
            return Integer.MAX_VALUE;
        else
            return (int)sum;
    }

    /**
     * Returns the value to which the specified key is mapped,
     * or {@code null} if this map contains no mapping for the key.
     *
     * &lt;p&gt;More formally, if this map contains a mapping from a key
     * {@code k} to a value {@code v} such that {@code key.equals(k)},
     * then this method returns {@code v}; otherwise it returns
     * {@code null}.  (There can be at most one such mapping.)
     *
     * @throws NullPointerException if the specified key is null
     */
    public V get(Object key) {
        int hash = hash(key.hashCode());</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/greencheek/concurrent/ConcurrentWeakHashMap.java</td><td><a href="./xref/org/greencheek/concurrent/ConcurrentWeakHashMap.html#1057">1057</a></td></tr><tr class="a"><td>org/greencheek/jboss/ConcurrentReferenceHashMap.java</td><td><a href="./xref/org/greencheek/jboss/ConcurrentReferenceHashMap.html#1334">1334</a></td></tr><tr class="b"><td colspan='2'><div><pre>            segments[i].clear();
    }

    /**
     * Returns a {@link Set} view of the keys contained in this map.
     * The set is backed by the map, so changes to the map are
     * reflected in the set, and vice-versa.  The set supports element
     * removal, which removes the corresponding mapping from this map,
     * via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;,
     * &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt;
     * operations.  It does not support the &lt;tt&gt;add&lt;/tt&gt; or
     * &lt;tt&gt;addAll&lt;/tt&gt; operations.
     *
     * &lt;p&gt;The view's &lt;tt&gt;iterator&lt;/tt&gt; is a &quot;weakly consistent&quot; iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public Set&lt;K&gt; keySet() {
        Set&lt;K&gt; ks = keySet;
        return (ks != null) ? ks : (keySet = new KeySet());
    }

    /**
     * Returns a {@link Collection} view of the values contained in this map.
     * The collection is backed by the map, so changes to the map are
     * reflected in the collection, and vice-versa.  The collection
     * supports element removal, which removes the corresponding
     * mapping from this map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,
     * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;,
     * &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not
     * support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.
     *
     * &lt;p&gt;The view's &lt;tt&gt;iterator&lt;/tt&gt; is a &quot;weakly consistent&quot; iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public Collection&lt;V&gt; values() {
        Collection&lt;V&gt; vs = values;
        return (vs != null) ? vs : (values = new Values());
    }

    /**
     * Returns a {@link Set} view of the mappings contained in this map.
     * The set is backed by the map, so changes to the map are
     * reflected in the set, and vice-versa.  The set supports element
     * removal, which removes the corresponding mapping from the map,
     * via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;,
     * &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt;
     * operations.  It does not support the &lt;tt&gt;add&lt;/tt&gt; or
     * &lt;tt&gt;addAll&lt;/tt&gt; operations.
     *
     * &lt;p&gt;The view's &lt;tt&gt;iterator&lt;/tt&gt; is a &quot;weakly consistent&quot; iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
        Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;
        return (es != null) ? es : (entrySet = new EntrySet());
    }

    /**
     * Returns an enumeration of the keys in this table.
     *
     * @return an enumeration of the keys in this table
     * @see #keySet()
     */
    public Enumeration&lt;K&gt; keys() {
        return new KeyIterator();
    }

    /**
     * Returns an enumeration of the values in this table.
     *
     * @return an enumeration of the values in this table
     * @see #values()
     */
    public Enumeration&lt;V&gt; elements() {
        return new ValueIterator();
    }

    /* ---------------- Iterator Support -------------- */

    abstract class HashIterator {
        int nextSegmentIndex;
        int nextTableIndex;
        HashEntry&lt;K,V&gt;[] currentTable;
        HashEntry&lt;K, V&gt; nextEntry;
        HashEntry&lt;K, V&gt; lastReturned;
        K currentKey; // Strong reference to weak key (prevents gc)

        HashIterator() {
            nextSegmentIndex = segments.length - 1;
            nextTableIndex = -1;
            advance();
        }

        public boolean hasMoreElements() { return hasNext(); }

        final void advance() {
            if (nextEntry != null &amp;&amp; (nextEntry = nextEntry.next) != null)
                return;

            while (nextTableIndex &gt;= 0) {
                if ( (nextEntry = currentTable[nextTableIndex--]) != null)
                    return;
            }

            while (nextSegmentIndex &gt;= 0) {
                Segment&lt;K,V&gt; seg = segments[nextSegmentIndex--];
                if (seg.count != 0) {
                    currentTable = seg.table;
                    for (int j = currentTable.length - 1; j &gt;= 0; --j) {
                        if ( (nextEntry = currentTable[j]) != null) {
                            nextTableIndex = j - 1;
                            return;
                        }
                    }
                }
            }
        }

        public boolean hasNext() { 
            while (nextEntry != null) {
                if (nextEntry.keyRef.get() != null) </pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/greencheek/concurrent/ConcurrentWeakHashMap.java</td><td><a href="./xref/org/greencheek/concurrent/ConcurrentWeakHashMap.html#499">499</a></td></tr><tr class="a"><td>org/greencheek/jboss/ConcurrentReferenceHashMap.java</td><td><a href="./xref/org/greencheek/jboss/ConcurrentReferenceHashMap.html#711">711</a></td></tr><tr class="b"><td colspan='2'><div><pre>                    tab[index] = new HashEntry&lt;K,V&gt;(key, hash, first, value, refQueue);
                    count = c; // write-volatile
                }
                return oldValue;
            } finally {
                unlock();
            }
        }

        int rehash() {
            HashEntry&lt;K,V&gt;[] oldTable = table;
            int oldCapacity = oldTable.length;
            if (oldCapacity &gt;= MAXIMUM_CAPACITY)
                return 0;

            /*
             * Reclassify nodes in each list to new Map.  Because we are
             * using power-of-two expansion, the elements from each bin
             * must either stay at same index, or move with a power of two
             * offset. We eliminate unnecessary node creation by catching
             * cases where old nodes can be reused because their next
             * fields won't change. Statistically, at the default
             * threshold, only about one-sixth of them need cloning when
             * a table doubles. The nodes they replace will be garbage
             * collectable as soon as they are no longer referenced by any
             * reader thread that may be in the midst of traversing table
             * right now.
             */

            HashEntry&lt;K,V&gt;[] newTable = HashEntry.newArray(oldCapacity&lt;&lt;1);
            threshold = (int)(newTable.length * loadFactor);
            int sizeMask = newTable.length - 1;
            int reduce = 0;
            for (int i = 0; i &lt; oldCapacity ; i++) {
                // We need to guarantee that any existing reads of old Map can
                //  proceed. So we cannot yet null out each bin.
                HashEntry&lt;K,V&gt; e = oldTable[i];

                if (e != null) {
                    HashEntry&lt;K,V&gt; next = e.next;
                    int idx = e.hash &amp; sizeMask;

                    //  Single node on list
                    if (next == null)
                        newTable[idx] = e;

                    else {
                        // Reuse trailing consecutive sequence at same slot
                        HashEntry&lt;K,V&gt; lastRun = e;
                        int lastIdx = idx;
                        for (HashEntry&lt;K,V&gt; last = next;
                             last != null;
                             last = last.next) {
                            int k = last.hash &amp; sizeMask;
                            if (k != lastIdx) {
                                lastIdx = k;
                                lastRun = last;
                            }
                        }
                        newTable[lastIdx] = lastRun;
                        // Clone all remaining nodes
                        for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) {
                            // Skip GC'd weak refs
                            K key = p.keyRef.get();</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/greencheek/concurrent/ConcurrentWeakHashMap.java</td><td><a href="./xref/org/greencheek/concurrent/ConcurrentWeakHashMap.html#1269">1269</a></td></tr><tr class="a"><td>org/greencheek/jboss/ConcurrentReferenceHashMap.java</td><td><a href="./xref/org/greencheek/jboss/ConcurrentReferenceHashMap.html#1544">1544</a></td></tr><tr class="b"><td colspan='2'><div><pre>            Map.Entry e = (Map.Entry) o;
            return eq(key, e.getKey()) &amp;&amp; eq(value, e.getValue());
        }

        public int hashCode() {
            return (key == null ? 0 : key.hashCode())
                    ^ (value == null ? 0 : value.hashCode());
        }

        public String toString() {
            return key + &quot;=&quot; + value;
        }

        private static boolean eq(Object o1, Object o2) {
            return o1 == null ? o2 == null : o1.equals(o2);
        }
    }


    /**
     * Custom Entry class used by EntryIterator.next(), that relays setValue
     * changes to the underlying map.
     */
    final class WriteThroughEntry extends SimpleEntry&lt;K,V&gt;
    {
        private static final long serialVersionUID = -7900634345345313646L;

        WriteThroughEntry(K k, V v) {
            super(k,v);
        }

        /**
         * Set our entry's value and write through to the map. The
         * value to return is somewhat arbitrary here. Since a
         * WriteThroughEntry does not necessarily track asynchronous
         * changes, the most recent &quot;previous&quot; value could be
         * different from what we return (or could even have been
         * removed in which case the put will re-establish). We do not
         * and cannot guarantee more.
         */
        public V setValue(V value) {
            if (value == null) throw new NullPointerException();
            V v = super.setValue(value);</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/greencheek/concurrent/ConcurrentWeakHashMap.java</td><td><a href="./xref/org/greencheek/concurrent/ConcurrentWeakHashMap.html#908">908</a></td></tr><tr class="a"><td>org/greencheek/jboss/ConcurrentReferenceHashMap.java</td><td><a href="./xref/org/greencheek/jboss/ConcurrentReferenceHashMap.html#1169">1169</a></td></tr><tr class="b"><td colspan='2'><div><pre>                    if (mc[i] != segments[i].modCount) {
                        cleanSweep = false;
                        break;
                    }
                }
            }
            if (cleanSweep)
                return false;
        }
        // Resort to locking all segments
        for (int i = 0; i &lt; segments.length; ++i)
            segments[i].lock();
        boolean found = false;
        try {
            for (int i = 0; i &lt; segments.length; ++i) {
                if (segments[i].containsValue(value)) {
                    found = true;
                    break;
                }
            }
        } finally {
            for (int i = 0; i &lt; segments.length; ++i)
                segments[i].unlock();
        }
        return found;
    }

    /**
     * Legacy method testing if some key maps into the specified value
     * in this table.  This method is identical in functionality to
     * {@link #containsValue}, and exists solely to ensure
     * full compatibility with class {@link java.util.Hashtable},
     * which supported this method prior to introduction of the
     * Java Collections framework.

     * @param  value a value to search for
     * @return &lt;tt&gt;true&lt;/tt&gt; if and only if some key maps to the
     *         &lt;tt&gt;value&lt;/tt&gt; argument in this table as
     *         determined by the &lt;tt&gt;equals&lt;/tt&gt; method;
     *         &lt;tt&gt;false&lt;/tt&gt; otherwise
     * @throws NullPointerException if the specified value is null
     */
    public boolean contains(Object value) {
        return containsValue(value);
    }

    /**
     * Maps the specified key to the specified value in this table.
     * Neither the key nor the value can be null.
     *
     * &lt;p&gt; The value can be retrieved by calling the &lt;tt&gt;get&lt;/tt&gt; method
     * with a key that is equal to the original key.
     *
     * @param key key with which the specified value is to be associated
     * @param value value to be associated with the specified key
     * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or
     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;
     * @throws NullPointerException if the specified key or value is null
     */
    public V put(K key, V value) {
        if (value == null)
            throw new NullPointerException();
        int hash = hash(key.hashCode());</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/greencheek/concurrent/ConcurrentWeakHashMap.java</td><td><a href="./xref/org/greencheek/concurrent/ConcurrentWeakHashMap.html#1228">1228</a></td></tr><tr class="a"><td>org/greencheek/jboss/ConcurrentReferenceHashMap.java</td><td><a href="./xref/org/greencheek/jboss/ConcurrentReferenceHashMap.html#1504">1504</a></td></tr><tr class="b"><td colspan='2'><div><pre>        public V nextElement() { return super.nextEntry().value; }
    }

     /*
      * This class is needed for JDK5 compatibility.
      */
     static class SimpleEntry&lt;K, V&gt; implements Entry&lt;K, V&gt;,
            java.io.Serializable {
        private static final long serialVersionUID = -8499721149061103585L;

        private final K key;
        private V value;

        public SimpleEntry(K key, V value) {
            this.key = key;
            this.value = value;
        }

        public SimpleEntry(Entry&lt;? extends K, ? extends V&gt; entry) {
            this.key = entry.getKey();
            this.value = entry.getValue();
        }

        public K getKey() {
            return key;
        }

        public V getValue() {
            return value;
        }

        public V setValue(V value) {
            V oldValue = this.value;
            this.value = value;
            return oldValue;
        }

        public boolean equals(Object o) {
            if (!(o instanceof Map.Entry))
                return false;</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/greencheek/concurrent/ConcurrentWeakHashMap.java</td><td><a href="./xref/org/greencheek/concurrent/ConcurrentWeakHashMap.html#464">464</a></td></tr><tr class="a"><td>org/greencheek/jboss/ConcurrentReferenceHashMap.java</td><td><a href="./xref/org/greencheek/jboss/ConcurrentReferenceHashMap.html#676">676</a></td></tr><tr class="b"><td colspan='2'><div><pre>                }
                return oldValue;
            } finally {
                unlock();
            }
        }


        V put(K key, int hash, V value, boolean onlyIfAbsent) {
            lock();
            try {
                removeStale();
                int c = count;
                if (c++ &gt; threshold) {// ensure capacity
                    int reduced = rehash();
                    if (reduced &gt; 0)  // adjust from possible weak cleanups
                        count = (c -= reduced) - 1; // write-volatile      
                }
                         
                HashEntry&lt;K,V&gt;[] tab = table;
                int index = hash &amp; (tab.length - 1);
                HashEntry&lt;K,V&gt; first = tab[index];
                HashEntry&lt;K,V&gt; e = first;
                while (e != null &amp;&amp; (e.hash != hash || !key.equals(e.keyRef.get())))</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/greencheek/concurrent/ConcurrentWeakHashMap.java</td><td><a href="./xref/org/greencheek/concurrent/ConcurrentWeakHashMap.html#1420">1420</a></td></tr><tr class="a"><td>org/greencheek/jboss/ConcurrentReferenceHashMap.java</td><td><a href="./xref/org/greencheek/jboss/ConcurrentReferenceHashMap.html#1693">1693</a></td></tr><tr class="b"><td colspan='2'><div><pre>                        s.writeObject(e.value);
                    }
                }
            } finally {
                seg.unlock();
            }
        }
        s.writeObject(null);
        s.writeObject(null);
    }

    /**
     * Reconstitute the &lt;tt&gt;ConcurrentWeakHashMap&lt;/tt&gt; instance from a
     * stream (i.e., deserialize it).
     * @param s the stream
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private void readObject(java.io.ObjectInputStream s)
        throws IOException, ClassNotFoundException  {
        s.defaultReadObject();

        // Initialize each segment to be minimally sized, and let grow.
        for (int i = 0; i &lt; segments.length; ++i) {
            segments[i].setTable(new HashEntry[1]);
        }

        // Read the keys and values, and put the mappings in the table
        for (;;) {
            K key = (K) s.readObject();
            V value = (V) s.readObject();
            if (key == null)
                break;
            put(key, value);
        }
    }
}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/greencheek/concurrent/ConcurrentWeakHashMap.java</td><td><a href="./xref/org/greencheek/concurrent/ConcurrentWeakHashMap.html#1390">1390</a></td></tr><tr class="a"><td>org/greencheek/jboss/ConcurrentReferenceHashMap.java</td><td><a href="./xref/org/greencheek/jboss/ConcurrentReferenceHashMap.html#1663">1663</a></td></tr><tr class="b"><td colspan='2'><div><pre>            ConcurrentWeakHashMap.this.clear();
        }
    }

    /* ---------------- Serialization Support -------------- */

    /**
     * Save the state of the &lt;tt&gt;ConcurrentWeakHashMap&lt;/tt&gt; instance to a
     * stream (i.e., serialize it).
     * @param s the stream
     * @serialData
     * the key (Object) and value (Object)
     * for each key-value mapping, followed by a null pair.
     * The key-value mappings are emitted in no particular order.
     */
    private void writeObject(java.io.ObjectOutputStream s) throws IOException  {
        s.defaultWriteObject();

        for (int k = 0; k &lt; segments.length; ++k) {
            Segment&lt;K,V&gt; seg = segments[k];
            seg.lock();
            try {
                HashEntry&lt;K,V&gt;[] tab = seg.table;
                for (int i = 0; i &lt; tab.length; ++i) {
                    for (HashEntry&lt;K,V&gt; e = tab[i]; e != null; e = e.next) {
                        K key = e.keyRef.get();</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/greencheek/concurrent/ConcurrentWeakHashMap.java</td><td><a href="./xref/org/greencheek/concurrent/ConcurrentWeakHashMap.html#673">673</a></td></tr><tr class="a"><td>org/greencheek/jboss/ConcurrentReferenceHashMap.java</td><td><a href="./xref/org/greencheek/jboss/ConcurrentReferenceHashMap.html#891">891</a></td></tr><tr class="b"><td colspan='2'><div><pre>                             float loadFactor, int concurrencyLevel) {
        if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)
            throw new IllegalArgumentException();

        if (concurrencyLevel &gt; MAX_SEGMENTS)
            concurrencyLevel = MAX_SEGMENTS;

        // Find power-of-two sizes best matching arguments
        int sshift = 0;
        int ssize = 1;
        while (ssize &lt; concurrencyLevel) {
            ++sshift;
            ssize &lt;&lt;= 1;
        }
        segmentShift = 32 - sshift;
        segmentMask = ssize - 1;
        this.segments = Segment.newArray(ssize);

        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        int c = initialCapacity / ssize;
        if (c * ssize &lt; initialCapacity)
            ++c;
        int cap = 1;
        while (cap &lt; c)
            cap &lt;&lt;= 1;</pre></div></td></tr></table></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
              Copyright &#169;                   2013.
          All Rights Reserved.      
        
                  </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
